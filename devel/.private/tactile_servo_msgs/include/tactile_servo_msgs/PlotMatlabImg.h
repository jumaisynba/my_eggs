// Generated by gencpp from file tactile_servo_msgs/PlotMatlabImg.msg
// DO NOT EDIT!


#ifndef TACTILE_SERVO_MSGS_MESSAGE_PLOTMATLABIMG_H
#define TACTILE_SERVO_MSGS_MESSAGE_PLOTMATLABIMG_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>

namespace tactile_servo_msgs
{
template <class ContainerAllocator>
struct PlotMatlabImg_
{
  typedef PlotMatlabImg_<ContainerAllocator> Type;

  PlotMatlabImg_()
    : header()
    , fx(0.0)
    , fy(0.0)
    , fz(0.0)
    , fwx(0.0)
    , fwy(0.0)
    , fwz(0.0)
    , coc_x(0.0)
    , coc_y(0.0)
    , f(0.0)
    , zmp_x(0.0)
    , zmp_y(0.0)
    , orient_z(0.0)
    , cop_x(0.0)
    , cop_y(0.0)
    , coc_xd(0.0)
    , coc_yd(0.0)
    , fd(0.0)
    , zmp_xd(0.0)
    , zmp_yd(0.0)
    , orient_zd(0.0)
    , cop_xd(0.0)
    , cop_yd(0.0)
    , num_contours(0)
    , x_now(0.0)
    , y_now(0.0)
    , z_now(0.0)
    , wx_now(0.0)
    , wy_now(0.0)
    , wz_now(0.0)
    , ww_now(0.0)
    , x_des(0.0)
    , y_des(0.0)
    , z_des(0.0)
    , wx_des(0.0)
    , wy_des(0.0)
    , wz_des(0.0)
    , ww_des(0.0)
    , x_c(0.0)
    , y_c(0.0)
    , z_c(0.0)
    , dt(0.0)
    , time(0.0)
    , test_time2(0.0)
    , img()
    , is_in_contact_ur(false)
    , pixels_in_contact_ur(0)
    , highest_force_cell_ur(0.0)
    , real_total_force_ur(0.0)
    , current_state_ur(0.0)
    , joint_angles()
    , joint_efforts()
    , x_c1(0.0)
    , y_c1(0.0)
    , z_c1(0.0)
    , x_c2(0.0)
    , y_c2(0.0)
    , z_c2(0.0)
    , x_c3(0.0)
    , y_c3(0.0)
    , z_c3(0.0)
    , x_c4(0.0)
    , y_c4(0.0)
    , z_c4(0.0)
    , x_c5(0.0)
    , y_c5(0.0)
    , z_c5(0.0)
    , x_c6(0.0)
    , y_c6(0.0)
    , z_c6(0.0)
    , x_c7(0.0)
    , y_c7(0.0)
    , z_c7(0.0)
    , x_c8(0.0)
    , y_c8(0.0)
    , z_c8(0.0)
    , x_c9(0.0)
    , y_c9(0.0)
    , z_c9(0.0)
    , x_c10(0.0)
    , y_c10(0.0)
    , z_c10(0.0)
    , x_c11(0.0)
    , y_c11(0.0)
    , z_c11(0.0)
    , x_c12(0.0)
    , y_c12(0.0)
    , z_c12(0.0)
    , x_c13(0.0)
    , y_c13(0.0)
    , z_c13(0.0)
    , x_c14(0.0)
    , y_c14(0.0)
    , z_c14(0.0)
    , x_c15(0.0)
    , y_c15(0.0)
    , z_c15(0.0)  {
    }
  PlotMatlabImg_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , fx(0.0)
    , fy(0.0)
    , fz(0.0)
    , fwx(0.0)
    , fwy(0.0)
    , fwz(0.0)
    , coc_x(0.0)
    , coc_y(0.0)
    , f(0.0)
    , zmp_x(0.0)
    , zmp_y(0.0)
    , orient_z(0.0)
    , cop_x(0.0)
    , cop_y(0.0)
    , coc_xd(0.0)
    , coc_yd(0.0)
    , fd(0.0)
    , zmp_xd(0.0)
    , zmp_yd(0.0)
    , orient_zd(0.0)
    , cop_xd(0.0)
    , cop_yd(0.0)
    , num_contours(0)
    , x_now(0.0)
    , y_now(0.0)
    , z_now(0.0)
    , wx_now(0.0)
    , wy_now(0.0)
    , wz_now(0.0)
    , ww_now(0.0)
    , x_des(0.0)
    , y_des(0.0)
    , z_des(0.0)
    , wx_des(0.0)
    , wy_des(0.0)
    , wz_des(0.0)
    , ww_des(0.0)
    , x_c(0.0)
    , y_c(0.0)
    , z_c(0.0)
    , dt(0.0)
    , time(0.0)
    , test_time2(0.0)
    , img(_alloc)
    , is_in_contact_ur(false)
    , pixels_in_contact_ur(0)
    , highest_force_cell_ur(0.0)
    , real_total_force_ur(0.0)
    , current_state_ur(0.0)
    , joint_angles(_alloc)
    , joint_efforts(_alloc)
    , x_c1(0.0)
    , y_c1(0.0)
    , z_c1(0.0)
    , x_c2(0.0)
    , y_c2(0.0)
    , z_c2(0.0)
    , x_c3(0.0)
    , y_c3(0.0)
    , z_c3(0.0)
    , x_c4(0.0)
    , y_c4(0.0)
    , z_c4(0.0)
    , x_c5(0.0)
    , y_c5(0.0)
    , z_c5(0.0)
    , x_c6(0.0)
    , y_c6(0.0)
    , z_c6(0.0)
    , x_c7(0.0)
    , y_c7(0.0)
    , z_c7(0.0)
    , x_c8(0.0)
    , y_c8(0.0)
    , z_c8(0.0)
    , x_c9(0.0)
    , y_c9(0.0)
    , z_c9(0.0)
    , x_c10(0.0)
    , y_c10(0.0)
    , z_c10(0.0)
    , x_c11(0.0)
    , y_c11(0.0)
    , z_c11(0.0)
    , x_c12(0.0)
    , y_c12(0.0)
    , z_c12(0.0)
    , x_c13(0.0)
    , y_c13(0.0)
    , z_c13(0.0)
    , x_c14(0.0)
    , y_c14(0.0)
    , z_c14(0.0)
    , x_c15(0.0)
    , y_c15(0.0)
    , z_c15(0.0)  {
  (void)_alloc;
    }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef double _fx_type;
  _fx_type fx;

   typedef double _fy_type;
  _fy_type fy;

   typedef double _fz_type;
  _fz_type fz;

   typedef double _fwx_type;
  _fwx_type fwx;

   typedef double _fwy_type;
  _fwy_type fwy;

   typedef double _fwz_type;
  _fwz_type fwz;

   typedef double _coc_x_type;
  _coc_x_type coc_x;

   typedef double _coc_y_type;
  _coc_y_type coc_y;

   typedef double _f_type;
  _f_type f;

   typedef double _zmp_x_type;
  _zmp_x_type zmp_x;

   typedef double _zmp_y_type;
  _zmp_y_type zmp_y;

   typedef double _orient_z_type;
  _orient_z_type orient_z;

   typedef double _cop_x_type;
  _cop_x_type cop_x;

   typedef double _cop_y_type;
  _cop_y_type cop_y;

   typedef double _coc_xd_type;
  _coc_xd_type coc_xd;

   typedef double _coc_yd_type;
  _coc_yd_type coc_yd;

   typedef double _fd_type;
  _fd_type fd;

   typedef double _zmp_xd_type;
  _zmp_xd_type zmp_xd;

   typedef double _zmp_yd_type;
  _zmp_yd_type zmp_yd;

   typedef double _orient_zd_type;
  _orient_zd_type orient_zd;

   typedef double _cop_xd_type;
  _cop_xd_type cop_xd;

   typedef double _cop_yd_type;
  _cop_yd_type cop_yd;

   typedef int32_t _num_contours_type;
  _num_contours_type num_contours;

   typedef double _x_now_type;
  _x_now_type x_now;

   typedef double _y_now_type;
  _y_now_type y_now;

   typedef double _z_now_type;
  _z_now_type z_now;

   typedef double _wx_now_type;
  _wx_now_type wx_now;

   typedef double _wy_now_type;
  _wy_now_type wy_now;

   typedef double _wz_now_type;
  _wz_now_type wz_now;

   typedef double _ww_now_type;
  _ww_now_type ww_now;

   typedef double _x_des_type;
  _x_des_type x_des;

   typedef double _y_des_type;
  _y_des_type y_des;

   typedef double _z_des_type;
  _z_des_type z_des;

   typedef double _wx_des_type;
  _wx_des_type wx_des;

   typedef double _wy_des_type;
  _wy_des_type wy_des;

   typedef double _wz_des_type;
  _wz_des_type wz_des;

   typedef double _ww_des_type;
  _ww_des_type ww_des;

   typedef double _x_c_type;
  _x_c_type x_c;

   typedef double _y_c_type;
  _y_c_type y_c;

   typedef double _z_c_type;
  _z_c_type z_c;

   typedef double _dt_type;
  _dt_type dt;

   typedef double _time_type;
  _time_type time;

   typedef double _test_time2_type;
  _test_time2_type test_time2;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _img_type;
  _img_type img;

   typedef uint8_t _is_in_contact_ur_type;
  _is_in_contact_ur_type is_in_contact_ur;

   typedef int32_t _pixels_in_contact_ur_type;
  _pixels_in_contact_ur_type pixels_in_contact_ur;

   typedef double _highest_force_cell_ur_type;
  _highest_force_cell_ur_type highest_force_cell_ur;

   typedef double _real_total_force_ur_type;
  _real_total_force_ur_type real_total_force_ur;

   typedef double _current_state_ur_type;
  _current_state_ur_type current_state_ur;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _joint_angles_type;
  _joint_angles_type joint_angles;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _joint_efforts_type;
  _joint_efforts_type joint_efforts;

   typedef double _x_c1_type;
  _x_c1_type x_c1;

   typedef double _y_c1_type;
  _y_c1_type y_c1;

   typedef double _z_c1_type;
  _z_c1_type z_c1;

   typedef double _x_c2_type;
  _x_c2_type x_c2;

   typedef double _y_c2_type;
  _y_c2_type y_c2;

   typedef double _z_c2_type;
  _z_c2_type z_c2;

   typedef double _x_c3_type;
  _x_c3_type x_c3;

   typedef double _y_c3_type;
  _y_c3_type y_c3;

   typedef double _z_c3_type;
  _z_c3_type z_c3;

   typedef double _x_c4_type;
  _x_c4_type x_c4;

   typedef double _y_c4_type;
  _y_c4_type y_c4;

   typedef double _z_c4_type;
  _z_c4_type z_c4;

   typedef double _x_c5_type;
  _x_c5_type x_c5;

   typedef double _y_c5_type;
  _y_c5_type y_c5;

   typedef double _z_c5_type;
  _z_c5_type z_c5;

   typedef double _x_c6_type;
  _x_c6_type x_c6;

   typedef double _y_c6_type;
  _y_c6_type y_c6;

   typedef double _z_c6_type;
  _z_c6_type z_c6;

   typedef double _x_c7_type;
  _x_c7_type x_c7;

   typedef double _y_c7_type;
  _y_c7_type y_c7;

   typedef double _z_c7_type;
  _z_c7_type z_c7;

   typedef double _x_c8_type;
  _x_c8_type x_c8;

   typedef double _y_c8_type;
  _y_c8_type y_c8;

   typedef double _z_c8_type;
  _z_c8_type z_c8;

   typedef double _x_c9_type;
  _x_c9_type x_c9;

   typedef double _y_c9_type;
  _y_c9_type y_c9;

   typedef double _z_c9_type;
  _z_c9_type z_c9;

   typedef double _x_c10_type;
  _x_c10_type x_c10;

   typedef double _y_c10_type;
  _y_c10_type y_c10;

   typedef double _z_c10_type;
  _z_c10_type z_c10;

   typedef double _x_c11_type;
  _x_c11_type x_c11;

   typedef double _y_c11_type;
  _y_c11_type y_c11;

   typedef double _z_c11_type;
  _z_c11_type z_c11;

   typedef double _x_c12_type;
  _x_c12_type x_c12;

   typedef double _y_c12_type;
  _y_c12_type y_c12;

   typedef double _z_c12_type;
  _z_c12_type z_c12;

   typedef double _x_c13_type;
  _x_c13_type x_c13;

   typedef double _y_c13_type;
  _y_c13_type y_c13;

   typedef double _z_c13_type;
  _z_c13_type z_c13;

   typedef double _x_c14_type;
  _x_c14_type x_c14;

   typedef double _y_c14_type;
  _y_c14_type y_c14;

   typedef double _z_c14_type;
  _z_c14_type z_c14;

   typedef double _x_c15_type;
  _x_c15_type x_c15;

   typedef double _y_c15_type;
  _y_c15_type y_c15;

   typedef double _z_c15_type;
  _z_c15_type z_c15;





  typedef boost::shared_ptr< ::tactile_servo_msgs::PlotMatlabImg_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::tactile_servo_msgs::PlotMatlabImg_<ContainerAllocator> const> ConstPtr;

}; // struct PlotMatlabImg_

typedef ::tactile_servo_msgs::PlotMatlabImg_<std::allocator<void> > PlotMatlabImg;

typedef boost::shared_ptr< ::tactile_servo_msgs::PlotMatlabImg > PlotMatlabImgPtr;
typedef boost::shared_ptr< ::tactile_servo_msgs::PlotMatlabImg const> PlotMatlabImgConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::tactile_servo_msgs::PlotMatlabImg_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::tactile_servo_msgs::PlotMatlabImg_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::tactile_servo_msgs::PlotMatlabImg_<ContainerAllocator1> & lhs, const ::tactile_servo_msgs::PlotMatlabImg_<ContainerAllocator2> & rhs)
{
  return lhs.header == rhs.header &&
    lhs.fx == rhs.fx &&
    lhs.fy == rhs.fy &&
    lhs.fz == rhs.fz &&
    lhs.fwx == rhs.fwx &&
    lhs.fwy == rhs.fwy &&
    lhs.fwz == rhs.fwz &&
    lhs.coc_x == rhs.coc_x &&
    lhs.coc_y == rhs.coc_y &&
    lhs.f == rhs.f &&
    lhs.zmp_x == rhs.zmp_x &&
    lhs.zmp_y == rhs.zmp_y &&
    lhs.orient_z == rhs.orient_z &&
    lhs.cop_x == rhs.cop_x &&
    lhs.cop_y == rhs.cop_y &&
    lhs.coc_xd == rhs.coc_xd &&
    lhs.coc_yd == rhs.coc_yd &&
    lhs.fd == rhs.fd &&
    lhs.zmp_xd == rhs.zmp_xd &&
    lhs.zmp_yd == rhs.zmp_yd &&
    lhs.orient_zd == rhs.orient_zd &&
    lhs.cop_xd == rhs.cop_xd &&
    lhs.cop_yd == rhs.cop_yd &&
    lhs.num_contours == rhs.num_contours &&
    lhs.x_now == rhs.x_now &&
    lhs.y_now == rhs.y_now &&
    lhs.z_now == rhs.z_now &&
    lhs.wx_now == rhs.wx_now &&
    lhs.wy_now == rhs.wy_now &&
    lhs.wz_now == rhs.wz_now &&
    lhs.ww_now == rhs.ww_now &&
    lhs.x_des == rhs.x_des &&
    lhs.y_des == rhs.y_des &&
    lhs.z_des == rhs.z_des &&
    lhs.wx_des == rhs.wx_des &&
    lhs.wy_des == rhs.wy_des &&
    lhs.wz_des == rhs.wz_des &&
    lhs.ww_des == rhs.ww_des &&
    lhs.x_c == rhs.x_c &&
    lhs.y_c == rhs.y_c &&
    lhs.z_c == rhs.z_c &&
    lhs.dt == rhs.dt &&
    lhs.time == rhs.time &&
    lhs.test_time2 == rhs.test_time2 &&
    lhs.img == rhs.img &&
    lhs.is_in_contact_ur == rhs.is_in_contact_ur &&
    lhs.pixels_in_contact_ur == rhs.pixels_in_contact_ur &&
    lhs.highest_force_cell_ur == rhs.highest_force_cell_ur &&
    lhs.real_total_force_ur == rhs.real_total_force_ur &&
    lhs.current_state_ur == rhs.current_state_ur &&
    lhs.joint_angles == rhs.joint_angles &&
    lhs.joint_efforts == rhs.joint_efforts &&
    lhs.x_c1 == rhs.x_c1 &&
    lhs.y_c1 == rhs.y_c1 &&
    lhs.z_c1 == rhs.z_c1 &&
    lhs.x_c2 == rhs.x_c2 &&
    lhs.y_c2 == rhs.y_c2 &&
    lhs.z_c2 == rhs.z_c2 &&
    lhs.x_c3 == rhs.x_c3 &&
    lhs.y_c3 == rhs.y_c3 &&
    lhs.z_c3 == rhs.z_c3 &&
    lhs.x_c4 == rhs.x_c4 &&
    lhs.y_c4 == rhs.y_c4 &&
    lhs.z_c4 == rhs.z_c4 &&
    lhs.x_c5 == rhs.x_c5 &&
    lhs.y_c5 == rhs.y_c5 &&
    lhs.z_c5 == rhs.z_c5 &&
    lhs.x_c6 == rhs.x_c6 &&
    lhs.y_c6 == rhs.y_c6 &&
    lhs.z_c6 == rhs.z_c6 &&
    lhs.x_c7 == rhs.x_c7 &&
    lhs.y_c7 == rhs.y_c7 &&
    lhs.z_c7 == rhs.z_c7 &&
    lhs.x_c8 == rhs.x_c8 &&
    lhs.y_c8 == rhs.y_c8 &&
    lhs.z_c8 == rhs.z_c8 &&
    lhs.x_c9 == rhs.x_c9 &&
    lhs.y_c9 == rhs.y_c9 &&
    lhs.z_c9 == rhs.z_c9 &&
    lhs.x_c10 == rhs.x_c10 &&
    lhs.y_c10 == rhs.y_c10 &&
    lhs.z_c10 == rhs.z_c10 &&
    lhs.x_c11 == rhs.x_c11 &&
    lhs.y_c11 == rhs.y_c11 &&
    lhs.z_c11 == rhs.z_c11 &&
    lhs.x_c12 == rhs.x_c12 &&
    lhs.y_c12 == rhs.y_c12 &&
    lhs.z_c12 == rhs.z_c12 &&
    lhs.x_c13 == rhs.x_c13 &&
    lhs.y_c13 == rhs.y_c13 &&
    lhs.z_c13 == rhs.z_c13 &&
    lhs.x_c14 == rhs.x_c14 &&
    lhs.y_c14 == rhs.y_c14 &&
    lhs.z_c14 == rhs.z_c14 &&
    lhs.x_c15 == rhs.x_c15 &&
    lhs.y_c15 == rhs.y_c15 &&
    lhs.z_c15 == rhs.z_c15;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::tactile_servo_msgs::PlotMatlabImg_<ContainerAllocator1> & lhs, const ::tactile_servo_msgs::PlotMatlabImg_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace tactile_servo_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsFixedSize< ::tactile_servo_msgs::PlotMatlabImg_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::tactile_servo_msgs::PlotMatlabImg_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct IsMessage< ::tactile_servo_msgs::PlotMatlabImg_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::tactile_servo_msgs::PlotMatlabImg_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::tactile_servo_msgs::PlotMatlabImg_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::tactile_servo_msgs::PlotMatlabImg_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::tactile_servo_msgs::PlotMatlabImg_<ContainerAllocator> >
{
  static const char* value()
  {
    return "4ee7a297cb920cbf51bd3172311d37db";
  }

  static const char* value(const ::tactile_servo_msgs::PlotMatlabImg_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x4ee7a297cb920cbfULL;
  static const uint64_t static_value2 = 0x51bd3172311d37dbULL;
};

template<class ContainerAllocator>
struct DataType< ::tactile_servo_msgs::PlotMatlabImg_<ContainerAllocator> >
{
  static const char* value()
  {
    return "tactile_servo_msgs/PlotMatlabImg";
  }

  static const char* value(const ::tactile_servo_msgs::PlotMatlabImg_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::tactile_servo_msgs::PlotMatlabImg_<ContainerAllocator> >
{
  static const char* value()
  {
    return "Header header\n"
"float64 fx\n"
"float64 fy\n"
"float64 fz\n"
"float64 fwx\n"
"float64 fwy\n"
"float64 fwz\n"
"float64 coc_x\n"
"float64 coc_y\n"
"float64 f\n"
"float64 zmp_x\n"
"float64 zmp_y\n"
"float64 orient_z\n"
"float64 cop_x\n"
"float64 cop_y\n"
"float64 coc_xd\n"
"float64 coc_yd\n"
"float64 fd\n"
"float64 zmp_xd\n"
"float64 zmp_yd\n"
"float64 orient_zd\n"
"float64 cop_xd\n"
"float64 cop_yd\n"
"int32 num_contours\n"
"float64 x_now\n"
"float64 y_now\n"
"float64 z_now\n"
"float64 wx_now\n"
"float64 wy_now\n"
"float64 wz_now\n"
"float64 ww_now\n"
"float64 x_des\n"
"float64 y_des\n"
"float64 z_des\n"
"float64 wx_des\n"
"float64 wy_des\n"
"float64 wz_des\n"
"float64 ww_des\n"
"float64 x_c\n"
"float64 y_c\n"
"float64 z_c\n"
"float64 dt\n"
"float64 time\n"
"float64 test_time2\n"
"float64[] img # actual matrix data, size is (step * rows)\n"
"bool    is_in_contact_ur \n"
"int32    pixels_in_contact_ur\n"
"float64    highest_force_cell_ur \n"
"float64    real_total_force_ur\n"
"float64    current_state_ur\n"
"float64[] joint_angles\n"
"float64[] joint_efforts\n"
"float64 x_c1\n"
"float64 y_c1\n"
"float64 z_c1\n"
"float64 x_c2\n"
"float64 y_c2\n"
"float64 z_c2\n"
"float64 x_c3\n"
"float64 y_c3\n"
"float64 z_c3\n"
"float64 x_c4\n"
"float64 y_c4\n"
"float64 z_c4\n"
"float64 x_c5\n"
"float64 y_c5\n"
"float64 z_c5\n"
"float64 x_c6\n"
"float64 y_c6\n"
"float64 z_c6\n"
"float64 x_c7\n"
"float64 y_c7\n"
"float64 z_c7\n"
"float64 x_c8\n"
"float64 y_c8\n"
"float64 z_c8\n"
"float64 x_c9\n"
"float64 y_c9\n"
"float64 z_c9\n"
"float64 x_c10\n"
"float64 y_c10\n"
"float64 z_c10\n"
"float64 x_c11\n"
"float64 y_c11\n"
"float64 z_c11\n"
"float64 x_c12\n"
"float64 y_c12\n"
"float64 z_c12\n"
"float64 x_c13\n"
"float64 y_c13\n"
"float64 z_c13\n"
"float64 x_c14\n"
"float64 y_c14\n"
"float64 z_c14\n"
"float64 x_c15\n"
"float64 y_c15\n"
"float64 z_c15\n"
"\n"
"================================================================================\n"
"MSG: std_msgs/Header\n"
"# Standard metadata for higher-level stamped data types.\n"
"# This is generally used to communicate timestamped data \n"
"# in a particular coordinate frame.\n"
"# \n"
"# sequence ID: consecutively increasing ID \n"
"uint32 seq\n"
"#Two-integer timestamp that is expressed as:\n"
"# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n"
"# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n"
"# time-handling sugar is provided by the client library\n"
"time stamp\n"
"#Frame this data is associated with\n"
"string frame_id\n"
;
  }

  static const char* value(const ::tactile_servo_msgs::PlotMatlabImg_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::tactile_servo_msgs::PlotMatlabImg_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.fx);
      stream.next(m.fy);
      stream.next(m.fz);
      stream.next(m.fwx);
      stream.next(m.fwy);
      stream.next(m.fwz);
      stream.next(m.coc_x);
      stream.next(m.coc_y);
      stream.next(m.f);
      stream.next(m.zmp_x);
      stream.next(m.zmp_y);
      stream.next(m.orient_z);
      stream.next(m.cop_x);
      stream.next(m.cop_y);
      stream.next(m.coc_xd);
      stream.next(m.coc_yd);
      stream.next(m.fd);
      stream.next(m.zmp_xd);
      stream.next(m.zmp_yd);
      stream.next(m.orient_zd);
      stream.next(m.cop_xd);
      stream.next(m.cop_yd);
      stream.next(m.num_contours);
      stream.next(m.x_now);
      stream.next(m.y_now);
      stream.next(m.z_now);
      stream.next(m.wx_now);
      stream.next(m.wy_now);
      stream.next(m.wz_now);
      stream.next(m.ww_now);
      stream.next(m.x_des);
      stream.next(m.y_des);
      stream.next(m.z_des);
      stream.next(m.wx_des);
      stream.next(m.wy_des);
      stream.next(m.wz_des);
      stream.next(m.ww_des);
      stream.next(m.x_c);
      stream.next(m.y_c);
      stream.next(m.z_c);
      stream.next(m.dt);
      stream.next(m.time);
      stream.next(m.test_time2);
      stream.next(m.img);
      stream.next(m.is_in_contact_ur);
      stream.next(m.pixels_in_contact_ur);
      stream.next(m.highest_force_cell_ur);
      stream.next(m.real_total_force_ur);
      stream.next(m.current_state_ur);
      stream.next(m.joint_angles);
      stream.next(m.joint_efforts);
      stream.next(m.x_c1);
      stream.next(m.y_c1);
      stream.next(m.z_c1);
      stream.next(m.x_c2);
      stream.next(m.y_c2);
      stream.next(m.z_c2);
      stream.next(m.x_c3);
      stream.next(m.y_c3);
      stream.next(m.z_c3);
      stream.next(m.x_c4);
      stream.next(m.y_c4);
      stream.next(m.z_c4);
      stream.next(m.x_c5);
      stream.next(m.y_c5);
      stream.next(m.z_c5);
      stream.next(m.x_c6);
      stream.next(m.y_c6);
      stream.next(m.z_c6);
      stream.next(m.x_c7);
      stream.next(m.y_c7);
      stream.next(m.z_c7);
      stream.next(m.x_c8);
      stream.next(m.y_c8);
      stream.next(m.z_c8);
      stream.next(m.x_c9);
      stream.next(m.y_c9);
      stream.next(m.z_c9);
      stream.next(m.x_c10);
      stream.next(m.y_c10);
      stream.next(m.z_c10);
      stream.next(m.x_c11);
      stream.next(m.y_c11);
      stream.next(m.z_c11);
      stream.next(m.x_c12);
      stream.next(m.y_c12);
      stream.next(m.z_c12);
      stream.next(m.x_c13);
      stream.next(m.y_c13);
      stream.next(m.z_c13);
      stream.next(m.x_c14);
      stream.next(m.y_c14);
      stream.next(m.z_c14);
      stream.next(m.x_c15);
      stream.next(m.y_c15);
      stream.next(m.z_c15);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct PlotMatlabImg_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::tactile_servo_msgs::PlotMatlabImg_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::tactile_servo_msgs::PlotMatlabImg_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "fx: ";
    Printer<double>::stream(s, indent + "  ", v.fx);
    s << indent << "fy: ";
    Printer<double>::stream(s, indent + "  ", v.fy);
    s << indent << "fz: ";
    Printer<double>::stream(s, indent + "  ", v.fz);
    s << indent << "fwx: ";
    Printer<double>::stream(s, indent + "  ", v.fwx);
    s << indent << "fwy: ";
    Printer<double>::stream(s, indent + "  ", v.fwy);
    s << indent << "fwz: ";
    Printer<double>::stream(s, indent + "  ", v.fwz);
    s << indent << "coc_x: ";
    Printer<double>::stream(s, indent + "  ", v.coc_x);
    s << indent << "coc_y: ";
    Printer<double>::stream(s, indent + "  ", v.coc_y);
    s << indent << "f: ";
    Printer<double>::stream(s, indent + "  ", v.f);
    s << indent << "zmp_x: ";
    Printer<double>::stream(s, indent + "  ", v.zmp_x);
    s << indent << "zmp_y: ";
    Printer<double>::stream(s, indent + "  ", v.zmp_y);
    s << indent << "orient_z: ";
    Printer<double>::stream(s, indent + "  ", v.orient_z);
    s << indent << "cop_x: ";
    Printer<double>::stream(s, indent + "  ", v.cop_x);
    s << indent << "cop_y: ";
    Printer<double>::stream(s, indent + "  ", v.cop_y);
    s << indent << "coc_xd: ";
    Printer<double>::stream(s, indent + "  ", v.coc_xd);
    s << indent << "coc_yd: ";
    Printer<double>::stream(s, indent + "  ", v.coc_yd);
    s << indent << "fd: ";
    Printer<double>::stream(s, indent + "  ", v.fd);
    s << indent << "zmp_xd: ";
    Printer<double>::stream(s, indent + "  ", v.zmp_xd);
    s << indent << "zmp_yd: ";
    Printer<double>::stream(s, indent + "  ", v.zmp_yd);
    s << indent << "orient_zd: ";
    Printer<double>::stream(s, indent + "  ", v.orient_zd);
    s << indent << "cop_xd: ";
    Printer<double>::stream(s, indent + "  ", v.cop_xd);
    s << indent << "cop_yd: ";
    Printer<double>::stream(s, indent + "  ", v.cop_yd);
    s << indent << "num_contours: ";
    Printer<int32_t>::stream(s, indent + "  ", v.num_contours);
    s << indent << "x_now: ";
    Printer<double>::stream(s, indent + "  ", v.x_now);
    s << indent << "y_now: ";
    Printer<double>::stream(s, indent + "  ", v.y_now);
    s << indent << "z_now: ";
    Printer<double>::stream(s, indent + "  ", v.z_now);
    s << indent << "wx_now: ";
    Printer<double>::stream(s, indent + "  ", v.wx_now);
    s << indent << "wy_now: ";
    Printer<double>::stream(s, indent + "  ", v.wy_now);
    s << indent << "wz_now: ";
    Printer<double>::stream(s, indent + "  ", v.wz_now);
    s << indent << "ww_now: ";
    Printer<double>::stream(s, indent + "  ", v.ww_now);
    s << indent << "x_des: ";
    Printer<double>::stream(s, indent + "  ", v.x_des);
    s << indent << "y_des: ";
    Printer<double>::stream(s, indent + "  ", v.y_des);
    s << indent << "z_des: ";
    Printer<double>::stream(s, indent + "  ", v.z_des);
    s << indent << "wx_des: ";
    Printer<double>::stream(s, indent + "  ", v.wx_des);
    s << indent << "wy_des: ";
    Printer<double>::stream(s, indent + "  ", v.wy_des);
    s << indent << "wz_des: ";
    Printer<double>::stream(s, indent + "  ", v.wz_des);
    s << indent << "ww_des: ";
    Printer<double>::stream(s, indent + "  ", v.ww_des);
    s << indent << "x_c: ";
    Printer<double>::stream(s, indent + "  ", v.x_c);
    s << indent << "y_c: ";
    Printer<double>::stream(s, indent + "  ", v.y_c);
    s << indent << "z_c: ";
    Printer<double>::stream(s, indent + "  ", v.z_c);
    s << indent << "dt: ";
    Printer<double>::stream(s, indent + "  ", v.dt);
    s << indent << "time: ";
    Printer<double>::stream(s, indent + "  ", v.time);
    s << indent << "test_time2: ";
    Printer<double>::stream(s, indent + "  ", v.test_time2);
    s << indent << "img[]" << std::endl;
    for (size_t i = 0; i < v.img.size(); ++i)
    {
      s << indent << "  img[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.img[i]);
    }
    s << indent << "is_in_contact_ur: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.is_in_contact_ur);
    s << indent << "pixels_in_contact_ur: ";
    Printer<int32_t>::stream(s, indent + "  ", v.pixels_in_contact_ur);
    s << indent << "highest_force_cell_ur: ";
    Printer<double>::stream(s, indent + "  ", v.highest_force_cell_ur);
    s << indent << "real_total_force_ur: ";
    Printer<double>::stream(s, indent + "  ", v.real_total_force_ur);
    s << indent << "current_state_ur: ";
    Printer<double>::stream(s, indent + "  ", v.current_state_ur);
    s << indent << "joint_angles[]" << std::endl;
    for (size_t i = 0; i < v.joint_angles.size(); ++i)
    {
      s << indent << "  joint_angles[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.joint_angles[i]);
    }
    s << indent << "joint_efforts[]" << std::endl;
    for (size_t i = 0; i < v.joint_efforts.size(); ++i)
    {
      s << indent << "  joint_efforts[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.joint_efforts[i]);
    }
    s << indent << "x_c1: ";
    Printer<double>::stream(s, indent + "  ", v.x_c1);
    s << indent << "y_c1: ";
    Printer<double>::stream(s, indent + "  ", v.y_c1);
    s << indent << "z_c1: ";
    Printer<double>::stream(s, indent + "  ", v.z_c1);
    s << indent << "x_c2: ";
    Printer<double>::stream(s, indent + "  ", v.x_c2);
    s << indent << "y_c2: ";
    Printer<double>::stream(s, indent + "  ", v.y_c2);
    s << indent << "z_c2: ";
    Printer<double>::stream(s, indent + "  ", v.z_c2);
    s << indent << "x_c3: ";
    Printer<double>::stream(s, indent + "  ", v.x_c3);
    s << indent << "y_c3: ";
    Printer<double>::stream(s, indent + "  ", v.y_c3);
    s << indent << "z_c3: ";
    Printer<double>::stream(s, indent + "  ", v.z_c3);
    s << indent << "x_c4: ";
    Printer<double>::stream(s, indent + "  ", v.x_c4);
    s << indent << "y_c4: ";
    Printer<double>::stream(s, indent + "  ", v.y_c4);
    s << indent << "z_c4: ";
    Printer<double>::stream(s, indent + "  ", v.z_c4);
    s << indent << "x_c5: ";
    Printer<double>::stream(s, indent + "  ", v.x_c5);
    s << indent << "y_c5: ";
    Printer<double>::stream(s, indent + "  ", v.y_c5);
    s << indent << "z_c5: ";
    Printer<double>::stream(s, indent + "  ", v.z_c5);
    s << indent << "x_c6: ";
    Printer<double>::stream(s, indent + "  ", v.x_c6);
    s << indent << "y_c6: ";
    Printer<double>::stream(s, indent + "  ", v.y_c6);
    s << indent << "z_c6: ";
    Printer<double>::stream(s, indent + "  ", v.z_c6);
    s << indent << "x_c7: ";
    Printer<double>::stream(s, indent + "  ", v.x_c7);
    s << indent << "y_c7: ";
    Printer<double>::stream(s, indent + "  ", v.y_c7);
    s << indent << "z_c7: ";
    Printer<double>::stream(s, indent + "  ", v.z_c7);
    s << indent << "x_c8: ";
    Printer<double>::stream(s, indent + "  ", v.x_c8);
    s << indent << "y_c8: ";
    Printer<double>::stream(s, indent + "  ", v.y_c8);
    s << indent << "z_c8: ";
    Printer<double>::stream(s, indent + "  ", v.z_c8);
    s << indent << "x_c9: ";
    Printer<double>::stream(s, indent + "  ", v.x_c9);
    s << indent << "y_c9: ";
    Printer<double>::stream(s, indent + "  ", v.y_c9);
    s << indent << "z_c9: ";
    Printer<double>::stream(s, indent + "  ", v.z_c9);
    s << indent << "x_c10: ";
    Printer<double>::stream(s, indent + "  ", v.x_c10);
    s << indent << "y_c10: ";
    Printer<double>::stream(s, indent + "  ", v.y_c10);
    s << indent << "z_c10: ";
    Printer<double>::stream(s, indent + "  ", v.z_c10);
    s << indent << "x_c11: ";
    Printer<double>::stream(s, indent + "  ", v.x_c11);
    s << indent << "y_c11: ";
    Printer<double>::stream(s, indent + "  ", v.y_c11);
    s << indent << "z_c11: ";
    Printer<double>::stream(s, indent + "  ", v.z_c11);
    s << indent << "x_c12: ";
    Printer<double>::stream(s, indent + "  ", v.x_c12);
    s << indent << "y_c12: ";
    Printer<double>::stream(s, indent + "  ", v.y_c12);
    s << indent << "z_c12: ";
    Printer<double>::stream(s, indent + "  ", v.z_c12);
    s << indent << "x_c13: ";
    Printer<double>::stream(s, indent + "  ", v.x_c13);
    s << indent << "y_c13: ";
    Printer<double>::stream(s, indent + "  ", v.y_c13);
    s << indent << "z_c13: ";
    Printer<double>::stream(s, indent + "  ", v.z_c13);
    s << indent << "x_c14: ";
    Printer<double>::stream(s, indent + "  ", v.x_c14);
    s << indent << "y_c14: ";
    Printer<double>::stream(s, indent + "  ", v.y_c14);
    s << indent << "z_c14: ";
    Printer<double>::stream(s, indent + "  ", v.z_c14);
    s << indent << "x_c15: ";
    Printer<double>::stream(s, indent + "  ", v.x_c15);
    s << indent << "y_c15: ";
    Printer<double>::stream(s, indent + "  ", v.y_c15);
    s << indent << "z_c15: ";
    Printer<double>::stream(s, indent + "  ", v.z_c15);
  }
};

} // namespace message_operations
} // namespace ros

#endif // TACTILE_SERVO_MSGS_MESSAGE_PLOTMATLABIMG_H
